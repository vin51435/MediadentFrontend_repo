import { activeHost, postData } from '@src/config/apiConfig';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { io } from 'socket.io-client';
import { useSelector } from 'react-redux';

const WEBPUSH_PUBLIC_KEY = import.meta.env.VITE_WEBPUSH_PUBLICKEY;
const SocketContext = createContext(null);

export const useSocket = () => useContext(SocketContext);

export const SocketProvider = ({ children }) => {
  const [socket, setSocket] = useState(null);
  const [isPrimary, setIsPrimary] = useState(false);
  const channel = new BroadcastChannel('socket_channel');
  const { token } = useSelector((state) => state.auth);

  useEffect(() => {
    if (!token) {
      console.log('No token; skipping socket initialization');
      return;
    }

    const initializeSocket = () => {
      const newSocket = io(activeHost, {
        auth: { token },
        transports: ['websocket'],
      });

      setSocket(newSocket);
      console.log('Primary tab: Socket initialized and connected');

      newSocket.on('receiveMessage', (message) => {
        console.log('Received message on primary tab:', message);
        channel.postMessage({ type: 'message', data: message });
      });

      newSocket.on('disconnect', () => {
        console.log('Socket disconnected');
      });

      newSocket.on('error', (error) => {
        console.error('Socket error:', error.message);
      });

      return newSocket;
    };

    // Handle incoming messages on BroadcastChannel
    channel.onmessage = (event) => {
      if (event.data.type === 'message' && !isPrimary) {
        console.log('Relayed message from primary tab:', event.data.data);
        // Handle the relayed message as if it were from the socket
      } else if (event.data.type === 'primary') {
        setIsPrimary(false);
      }
    };

    // Primary tab setup
    const setPrimaryTab = () => {
      setIsPrimary(true);
      const newSocket = initializeSocket();
      channel.postMessage({ type: 'primary' });
      subscribeToPushNotifications();
      return newSocket;
    };

    // Check if any tab is already the primary tab
    const primaryTimeout = setTimeout(() => {
      if (!isPrimary) {
        setPrimaryTab();
      }
    }, 500);

    return () => {
      clearTimeout(primaryTimeout);
      if (isPrimary) {
        socket && socket.disconnect();
        channel.close();
      }
    };
  }, [token]);

  const requestNotificationPermission = async () => {
    const permission = await Notification.requestPermission();
    return permission === 'granted';
  };

  const subscribeToPushNotifications = async () => {
    const permissionGranted = await requestNotificationPermission();
    if (!permissionGranted) {
      console.log('Notification permission denied');
      return;
    }

    if ('serviceWorker' in navigator && 'PushManager' in window) {
      try {
        const registration = await navigator.serviceWorker.register("/service-worker.js");
        console.log('Service Worker registered');

        const subscription = await registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: WEBPUSH_PUBLIC_KEY,
        });

        await postData('/subscribe', {
          baseURL: 'user',
          data: subscription,
        });
        console.log('Subscribed to push notifications');
      } catch (error) {
        console.error('Push notification subscription failed:', error);
      }
    }
  };

  return <SocketContext.Provider value={socket}>{children}</SocketContext.Provider>;
};

export default SocketProvider;
